Розробити функцію super_fibonacci(n, m), 
яка приймає 2 аргументи -- додатні цілі числа n та m (0 < n, m <= 35), 
та повертає число -- n-й елемент послідовності супер-Фібоначчі порядку m.

Нагадуємо, що послідовність Фібоначчі -- це послідовність чисел, в якій кожний елемент дорівнює сумі двох попередніх. Послідовністю супер-Фібоначчі порядку m будемо вважати таку послідовність чисел, в якій кожний елемент дорівнює сумі m попередніх. Перші m елементів (з порядковими номерами від 1 до m) вважатимемо одиницями.

Наприклад
Виклик функції: super_fibonacci(2, 1)
Повертає: 1
Виклик функції: super_fibonacci(3, 5)
Повертає: 1
Виклик функції: super_fibonacci(8, 2)
Повертає: 21
Виклик функції: super_fibonacci(9, 3)
Повертає: 57

import sys

n = int(sys.argv[1])
m = int(sys.argv[2])

def super_fibonacci(n,m):
    # функція пошуку N-го елементу в M послідовноссті супер-фібоначчі
    # перевіряємо чи N виходить за межі M
    if n <= m or m == 1 :
        return 1
    # створюємо масив з перших M-елементів
    First_list = [1 for x in range(m)]
    # проходимо цикл і додаємо N елементів в наш список фібоначчі
    for i in range(m,n+1):
        #суму попередніх M елементів знахоимо за допомогою зрізу
        First_list.append(sum(First_list[len(First_list)-m:]))
    return First_list[n-1]
print(super_fibonacci(n,m))


########################################## 2 Варіант ##########################################
def super_fibonacci(n, m):
    # за умовою перші m елементів - одиниці
    if n<=m:
        return 1
    # інакше доведеться рахувати
    else:
        # ініціалізуємо змінну для суми
        sum = 0
        # і додаємо m попередніх членів послідовності, для розрахунку кожного з них рекурсивно викликаємо нашу функцію
        for i in range(1, m+1):
            previous = super_fibonacci(n-i, m)
            sum = sum + previous
        # повертаємо суму, яка є значенням n-го елементу
        return sum
